package sun.security.tools.keytool.resources;

import java.util.ListResourceBundle;

public final class keytool_de extends ListResourceBundle {
    protected final Object[][] getContents() {
        return new Object[][] {
            { ".Empty.value.", "(Leerer Wert)" },
            { ".OPTION.", " [OPTION]..." },
            { ".PATTERN.printX509Cert.with.weak", "Eigent\u00FCmer: {0}\nAussteller: {1}\nSeriennummer: {2}\nG\u00FCltig von: {3} bis: {4}\nZertifikatsfingerprints:\n\t SHA1: {5}\n\t SHA256: {6}\nSignaturalgorithmusname: {7}\nPublic-Key-Algorithmus von Subject: {8}\nVersion: {9}" },
            { ".RETURN.if.same.as.for.otherAlias.", "\t(RETURN, wenn identisch mit <{0}>)" },
            { ".RETURN.if.same.as.keystore.password.", "\t(RETURN, wenn identisch mit Keystore-Kennwort):  " },
            { ".Storing.ksfname.", "[{0} wird gespeichert]" },
            { ".The.integrity.of.the.information.stored.in.the.srckeystore.", "* Die Integrit\u00E4t der Informationen, die in Ihrem Srckeystore gespeichert sind, *\n* wurde NICHT gepr\u00FCft. Um die Integrit\u00E4t zu pr\u00FCfen, *\n* m\u00FCssen Sie Ihr Srckeystore-Kennwort angeben.                  *" },
            { ".The.integrity.of.the.information.stored.in.your.keystore.", "* Die Integrit\u00E4t der Informationen, die in Ihrem Keystore gespeichert sind, *\n* wurde NICHT gepr\u00FCft. Um die Integrit\u00E4t zu pr\u00FCfen, *\n* m\u00FCssen Sie Ihr Keystore-Kennwort angeben.                  *" },
            { ".WARNING.WARNING.WARNING.", "*****************  WARNING WARNING WARNING  *****************" },
            { ".defaultValue.", "  [{0}]:  " },
            { ".is.not.trusted.", "... ist nicht vertrauensw\u00FCrdig. " },
            { ".keypass.and.new.can.not.be.specified.if.storetype.is.{0}", "-keypass und -new k\u00F6nnen nicht angegeben werden, wenn -storetype {0} ist" },
            { ".keypasswd.commands.not.supported.if.storetype.is.PKCS12", "Befehle des Typs -keypasswd werden nicht unterst\u00FCtzt, wenn -storetype PKCS12 ist" },
            { ".keystore.must.be.NONE.if.storetype.is.{0}", "-keystore muss NONE sein, wenn -storetype {0} ist" },
            { ".storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}", "Befehle -storepasswd und -keypasswd werden nicht unterst\u00FCtzt, wenn -storetype {0} ist" },
            { "Alias.alias.does.not.exist", "Alias <{0}> ist nicht vorhanden" },
            { "Alias.alias.has.no.certificate", "Alias <{0}> hat kein Zertifikat" },
            { "Alias.alias.has.no.key", "Alias <{0}> verf\u00FCgt \u00FCber keinen Schl\u00FCssel" },
            { "Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key", "Alias <{0}> verweist auf einen Eintragstyp, der kein Private-Key-Eintrag ist. Der Befehl -keyclone unterst\u00FCtzt nur das Klonen von Private-Key-Eintr\u00E4gen" },
            { "Alias.name.alias", "Aliasname: {0}" },
            { "Cannot.derive.signature.algorithm", "Signaturalgorithmus kann nicht abgeleitet werden" },
            { "Cannot.find.environment.variable.", "Umgebungsvariable kann nicht gefunden werden: " },
            { "Cannot.find.file.", "Datei kann nicht gefunden werden: " },
            { "Certificate.already.exists.in.keystore.under.alias.trustalias.", "Zertifikat ist bereits unter Alias <{0}> im Keystore vorhanden" },
            { "Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.", "Zertifikat ist bereits unter Alias <{0}> im systemweiten CA-Keystore vorhanden" },
            { "Certificate.chain.length.", "Zertifikatskettenl\u00E4nge: " },
            { "Certificate.d.", "Zertifikat #%d:" },
            { "Certificate.fingerprint.SHA.256.", "Zertifikat-Fingerprint (SHA-256): " },
            { "Certificate.i.1.", "Zertifikat[{0,number,integer}]:" },
            { "Certificate.not.imported.alias.alias.already.exists", "Zertifikat nicht importiert. Alias <{0}> ist bereits vorhanden" },
            { "Certificate.owner.", "Zertifikatseigent\u00FCmer: " },
            { "Certificate.reply.and.certificate.in.keystore.are.identical", "Zertifikatsantwort und Zertifikat in Keystore sind identisch" },
            { "Certificate.reply.does.not.contain.public.key.for.alias.", "Zertifikatsantwort enth\u00E4lt keinen Public Key f\u00FCr <{0}>" },
            { "Certificate.reply.was.installed.in.keystore", "Zertifikatsantwort wurde in Keystore installiert" },
            { "Certificate.reply.was.not.installed.in.keystore", "Zertifikatsantwort wurde nicht in Keystore installiert" },
            { "Certificate.stored.in.file.filename.", "Zertifikat in Datei <{0}> gespeichert" },
            { "Certificate.was.added.to.keystore", "Zertifikat wurde Keystore hinzugef\u00FCgt" },
            { "Certificate.was.not.added.to.keystore", "Zertifikat wurde nicht zu Keystore hinzugef\u00FCgt" },
            { "Certification.request.stored.in.file.filename.", "Zertifizierungsanforderung in Datei <{0}> gespeichert" },
            { "Changes.an.entry.s.alias", "\u00C4ndert den Alias eines Eintrags" },
            { "Changes.the.key.password.of.an.entry", "\u00C4ndert das Schl\u00FCsselkennwort eines Eintrags" },
            { "Changes.the.store.password.of.a.keystore", "\u00C4ndert das Speicherkennwort eines Keystores" },
            { "Clones.a.key.entry", "Clont einen Schl\u00FCsseleintrag" },
            { "Command.option.flag.needs.an.argument.", "Befehlsoption {0} ben\u00F6tigt ein Argument." },
            { "Commands.", "Befehle:" },
            { "Creation.date.keyStore.getCreationDate.alias.", "Erstellungsdatum: {0,date}" },
            { "Deletes.an.entry", "L\u00F6scht einen Eintrag" },
            { "Destination.alias.dest.already.exists", "Zielalias <{0}> bereits vorhanden" },
            { "Do.you.still.want.to.add.it.no.", "M\u00F6chten Sie es trotzdem hinzuf\u00FCgen? [Nein]:  " },
            { "Do.you.still.want.to.add.it.to.your.own.keystore.no.", "M\u00F6chten Sie es trotzdem zu Ihrem eigenen Keystore hinzuf\u00FCgen? [Nein]:  " },
            { "Empty.input", "Leere Eingabe" },
            { "Enter.alias.name.", "Aliasnamen eingeben:  " },
            { "Enter.destination.keystore.password.", "Ziel-Keystore-Kennwort eingeben:  " },
            { "Enter.key.password.for.alias.", "Schl\u00FCsselkennwort f\u00FCr <{0}> eingeben" },
            { "Enter.keystore.password.", "Keystore-Kennwort eingeben:  " },
            { "Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.", "Geben Sie einen neuen Aliasnamen ein\t(RETURN, um den Import dieses Eintrags abzubrechen):  " },
            { "Enter.prompt.alias.name.", "{0}-Aliasnamen eingeben:  " },
            { "Enter.source.keystore.password.", "Quell-Keystore-Kennwort eingeben:  " },
            { "Enter.the.password.to.be.stored.", "Geben Sie das Kennwort ein, das gespeichert werden soll:  " },
            { "Entry.for.alias.alias.not.imported.", "Eintrag f\u00FCr Alias {0} nicht importiert." },
            { "Entry.for.alias.alias.successfully.imported.", "Eintrag f\u00FCr Alias {0} erfolgreich importiert." },
            { "Entry.type.type.", "Eintragstyp: {0}" },
            { "Existing.entry.alias.alias.exists.overwrite.no.", "Eintragsalias {0} ist bereits vorhanden. \u00DCberschreiben? [Nein]:  " },
            { "Exports.certificate", "Exportiert ein Zertifikat" },
            { "Extension.Request.", "Erweiterungsanforderung:" },
            { "Extensions.", "Erweiterungen: " },
            { "Failed.to.establish.chain.from.reply", "Kette konnte der Antwort nicht entnommen werden" },
            { "Failed.to.parse.input", "Eingabe konnte nicht geparst werden" },
            { "Generated.keyAlgName.secret.key", "{0} Secret Key generiert" },
            { "Generated.keysize.bit.keyAlgName.secret.key", "{0}-Bit {1} Secret Key generiert" },
            { "Generates.CRL", "Generiert eine CRL" },
            { "Generates.a.certificate.request", "Generiert eine Zertifikatsanforderung" },
            { "Generates.a.key.pair", "Generiert ein Schl\u00FCsselpaar" },
            { "Generates.a.secret.key", "Generiert einen Secret Key" },
            { "Generates.a.self.signed.certificate", "Generiert ein selbst signiertes Zertifikat" },
            { "Generates.certificate.from.a.certificate.request", "Generiert ein Zertifikat aus einer Zertifikatsanforderung" },
            { "Generating.full.keyAlgName.key.pair.and.a.certificate.sigAlgName.issued.by.signerAlias.with.a.validity.of.days.for", "Generieren von {0}-Schl\u00FCsselpaar und einem von <{2}> ausgestellten Zertifikat ({1}) mit einer G\u00FCltigkeit von {3} Tagen\n\tf\u00FCr: {4}" },
            { "Generating.full.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.days.for", "Generieren von {0}-Schl\u00FCsselpaar und selbstsigniertem Zertifikat ({1}) mit einer G\u00FCltigkeit von {2} Tagen\n\tf\u00FCr: {3}" },
            { "Illegal.option.", "Unzul\u00E4ssige Option:  " },
            { "Illegal.startdate.value", "Unzul\u00E4ssiger Wert f\u00FCr Startdatum" },
            { "Illegal.value.", "Unzul\u00E4ssiger Wert: " },
            { "Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled", "Importbefehl abgeschlossen: {0} Eintr\u00E4ge erfolgreich importiert, {1} Eintr\u00E4ge nicht erfolgreich oder abgebrochen" },
            { "Imports.a.certificate.or.a.certificate.chain", "Importiert ein Zertifikat oder eine Zertifikatskette" },
            { "Imports.a.password", "Importiert ein Kennwort" },
            { "Imports.entries.from.a.JDK.1.1.x.style.identity.database", "Importiert Eintr\u00E4ge aus einer Identity-Datenbank im JDK 1.1.x-Stil" },
            { "Imports.one.or.all.entries.from.another.keystore", "Importiert einen oder alle Eintr\u00E4ge aus einem anderen Keystore" },
            { "Incomplete.certificate.chain.in.reply", "Unvollst\u00E4ndige Zertifikatskette in Antwort" },
            { "Input.not.an.X.509.certificate", "Eingabe kein X.509-Zertifikat" },
            { "Install.reply.anyway.no.", "Antwort trotzdem installieren? [Nein]:  " },
            { "Is.name.correct.", "Ist {0} richtig?" },
            { "Key.and.Certificate.Management.Tool", "Schl\u00FCssel- und Zertifikatsverwaltungstool" },
            { "Key.pair.not.generated.alias.alias.already.exists", "Schl\u00FCsselpaar wurde nicht generiert. Alias <{0}> ist bereits vorhanden" },
            { "Key.password.is.too.short.must.be.at.least.6.characters", "Schl\u00FCsselkennwort ist zu kurz. Es muss mindestens sechs Zeichen lang sein" },
            { "Key.password.must.be.at.least.6.characters", "Schl\u00FCsselkennwort muss mindestens sechs Zeichen lang sein" },
            { "Keystore.file.does.not.exist.", "Keystore-Datei ist nicht vorhanden: " },
            { "Keystore.file.exists.but.is.empty.", "Keystore-Datei ist vorhanden, ist aber leer: " },
            { "Keystore.password.is.too.short.must.be.at.least.6.characters", "Keystore-Kennwort ist zu kurz. Es muss mindestens sechs Zeichen lang sein" },
            { "Keystore.password.must.be.at.least.6.characters", "Keystore-Kennwort muss mindestens sechs Zeichen lang sein" },
            { "Keystore.provider.", "Keystore-Provider: " },
            { "Keystore.type.", "Keystore-Typ: " },
            { "Lists.entries.in.a.keystore", "Listet die Eintr\u00E4ge in einem Keystore auf" },
            { "Must.not.specify.both.v.and.rfc.with.list.command", "-v und -rfc d\u00FCrfen bei Befehl \"list\" nicht beide angegeben werden" },
            { "Must.specify.alias", "Sie m\u00FCssen einen Alias angeben" },
            { "Must.specify.destination.alias", "Sie m\u00FCssen einen Zielalias angeben" },
            { "NEWLINE", "\n" },
            { "New.certificate.self.signed.", "Neues Zertifikat (selbst signiert):" },
            { "New.password.must.be.at.least.6.characters", "Neues Kennwort muss mindestens sechs Zeichen lang sein" },
            { "New.prompt.", "{0} (neu): " },
            { "No.certificate.from.the.SSL.server", "Kein Zertifikat vom SSL-Server" },
            { "No.entries.from.identity.database.added", "Keine Eintr\u00E4ge aus Identity-Datenbank hinzugef\u00FCgt" },
            { "Not.X.509.certificate", "Kein X.509-Zertifikat" },
            { "Not.a.signed.jar.file", "Keine signierte JAR-Datei" },
            { "Odd.number.of.hex.digits.found.", "Ungerade Anzahl hexadezimaler Ziffern gefunden: " },
            { "Options.", "Optionen:" },
            { "PKCS.10.with.weak", "PKCS #10-Zertifikatsanforderung (Version 1.0)\nSubject: %1$s\nFormat: %2$s\nPublic Key: %3$s\nSignaturalgorithmus: %4$s\n" },
            { "Password.is.too.short.must.be.at.least.6.characters", "Kennwort ist zu kurz. Es muss mindestens sechs Zeichen lang sein" },
            { "Passwords.must.differ", "Kennw\u00F6rter m\u00FCssen sich unterscheiden" },
            { "Please.provide.keysize.for.secret.key.generation", "Geben Sie -keysize zum Erstellen eines Secret Key an" },
            { "Please.specify.srckeystore", "Geben Sie -srckeystore an" },
            { "Prints.the.content.of.a.CRL.file", "Druckt den Content einer CRL-Datei" },
            { "Prints.the.content.of.a.certificate", "Druckt den Content eines Zertifikats" },
            { "Prints.the.content.of.a.certificate.request", "Druckt den Content einer Zertifikatsanforderung" },
            { "Prints.the.program.version", "Gibt die Programmversion aus" },
            { "Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.", "Problem beim Importieren des Eintrags f\u00FCr Alias {0}: {1}.\nEintrag f\u00FCr Alias {0} nicht importiert." },
            { "Public.keys.in.reply.and.keystore.don.t.match", "Public Keys in Antwort und Keystore stimmen nicht \u00FCberein" },
            { "Re.enter.new.password.", "Neues Kennwort erneut eingeben: " },
            { "Re.enter.new.prompt.", "Neues {0} erneut eingeben: " },
            { "Re.enter.password.", "Geben Sie das Kennwort erneut ein: " },
            { "Reply.has.no.certificates", "Antwort hat keine Zertifikate" },
            { "SSL.server.host.and.port", "SSL-Serverhost und -port" },
            { "STAR", "*******************************************" },
            { "STARNN", "*******************************************\n\n" },
            { "Secret.key.not.generated.alias.alias.already.exists", "Secret Key wurde nicht generiert. Alias <{0}> ist bereits vorhanden" },
            { "Serial.ID.of.cert.to.revoke", "Serielle ID des zu entziehenden Certs" },
            { "Signer.d.", "Signaturgeber #%d:" },
            { "Source.keystore.file.exists.but.is.empty.", "Quell-Keystore-Datei ist zwar vorhanden, ist aber leer: " },
            { "Submit.this.to.your.CA", "Leiten Sie dies an die CA weiter" },
            { "The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.", "Der Ziel-Keystore pkcs12 hat unterschiedliche Kennw\u00F6rter f\u00FCr storepass und keypass. Wiederholen Sie den Vorgang, indem Sie -destkeypass angeben." },
            { "They.don.t.match.Try.again", "Keine \u00DCbereinstimmung. Wiederholen Sie den Vorgang" },
            { "This.extension.cannot.be.marked.as.critical.", "Erweiterung kann nicht als \"Kritisch\" markiert werden. " },
            { "Timestamp.", "Zeitstempel:" },
            { "Too.many.failures.Key.entry.not.cloned", "Zu viele Fehler. Schl\u00FCsseleintrag wurde nicht geklont" },
            { "Too.many.failures.key.not.added.to.keystore", "Zu viele Fehler. Schl\u00FCssel wurde nicht zu Keystore hinzugef\u00FCgt" },
            { "Too.many.failures.try.later", "Zu viele Fehler. Versuchen Sie es sp\u00E4ter erneut" },
            { "Too.many.retries.program.terminated", "Zu viele erneute Versuche. Programm wird beendet" },
            { "Top.level.certificate.in.reply.", "Zertifikat der obersten Ebene in Antwort:\n" },
            { "Trust.this.certificate.no.", "Diesem Zertifikat vertrauen? [Nein]:  " },
            { "Unable.to.parse.denyAfter.string.in.exception.message", "denyAfter-Datumszeichenfolge in Ausnahmemeldung kann nicht geparst werden" },
            { "Unknown.AccessDescription.type.", "Unbekannter AccessDescription-Typ: " },
            { "Unknown.Entry.Type", "Unbekannter Eintragstyp" },
            { "Unknown.extendedkeyUsage.type.", "Unbekannter extendedkeyUsage-Typ: " },
            { "Unknown.extension.type.", "Unbekannter Erweiterungstyp: " },
            { "Unknown.keyUsage.type.", "Unbekannter keyUsage-Typ: " },
            { "Unknown.password.type.", "Unbekannter Kennworttyp: " },
            { "Unrecognized.GeneralName.type.", "Unbekannter GeneralName-Typ: " },
            { "Usage.error.no.command.provided", "Verwendungsfehler: Kein Befehl angegeben" },
            { "Use.keytool.command.name.help.for.usage.of.command.name", "Verwenden Sie \"keytool -command_name --help\" f\u00FCr die Verwendung von command_name.\nVerwenden Sie die Option -conf <url>, um eine vorkonfigurierte Optionsdatei anzugeben." },
            { "Use.keytool.help.for.all.available.commands", "Verwenden Sie \"keytool -?, -h, or --help\" f\u00FCr diese Hilfemeldung" },
            { "Validity.must.be.greater.than.zero", "G\u00FCltigkeit muss gr\u00F6\u00DFer als null sein" },
            { "Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.", "Warnung: Keine Unterst\u00FCtzung f\u00FCr unterschiedliche Speicher- und Schl\u00FCsselkennw\u00F6rter bei PKCS12 KeyStores. Der benutzerdefinierte Wert {0} wird ignoriert." },
            { "Warning.Overwriting.existing.alias.alias.in.destination.keystore", "Warnung: Vorhandener Alias {0} in Ziel-Keystore wird \u00FCberschrieben" },
            { "What.is.the.name.of.your.City.or.Locality.", "Wie lautet der Name Ihrer Stadt oder Gemeinde?" },
            { "What.is.the.name.of.your.State.or.Province.", "Wie lautet der Name Ihres Bundeslands?" },
            { "What.is.the.name.of.your.organization.", "Wie lautet der Name Ihrer Organisation?" },
            { "What.is.the.name.of.your.organizational.unit.", "Wie lautet der Name Ihrer organisatorischen Einheit?" },
            { "What.is.the.two.letter.country.code.for.this.unit.", "Wie lautet der L\u00E4ndercode (zwei Buchstaben) f\u00FCr diese Einheit?" },
            { "What.is.your.first.and.last.name.", "Wie lautet Ihr Vor- und Nachname?" },
            { "Wrong.answer.try.again", "Falsche Antwort. Wiederholen Sie den Vorgang" },
            { "X.509.extension", "X.509-Erweiterung" },
            { "Your.keystore.contains.keyStore.size.entries", "Keystore enth\u00E4lt {0,number,integer} Eintr\u00E4ge" },
            { "Your.keystore.contains.keyStore.size.entry", "Keystore enth\u00E4lt {0,number,integer} Eintrag" },
            { "access.the.cacerts.keystore", "Zugriff auf den cacerts Keystore" },
            { "addprovider.option", "Sicherheitsprovider nach Name hinzuf\u00FCgen (z.B. SunPKCS11)\nArgument f\u00FCr -addprovider konfigurieren" },
            { "alias.", "{0}, " },
            { "alias.has.no.X.509.certificate", "{0} hat kein X.509-Zertifikat" },
            { "alias.has.no.public.key", "{0} hat keinen Public Key" },
            { "alias.has.no.public.key.certificate.", "{0} hat keinen Public Key (Zertifikat)" },
            { "alias.in.cacerts", "Aussteller <%s> in cacerts" },
            { "alias.in.keystore", "Aussteller <%s>" },
            { "alias.keyStore.getCreationDate.alias.", "{0}, {1,date}, " },
            { "alias.name.of.the.entry.to.process", "Aliasname des zu verarbeitenden Eintrags" },
            { "backup.keystore.warning", "Der urspr\u00FCngliche Keystore \"%1$s\" wird als \"%3$s\" gesichert..." },
            { "certificate.validity.start.date.time", "Startdatum/-zeit f\u00FCr Zertifikatsg\u00FCltigkeit" },
            { "command.{0}.is.ambiguous.", "Befehl {0} ist mehrdeutig:" },
            { "deprecate.keysize.for.ec", "Das Angeben von -keysize zum Generieren von EC-Schl\u00FCsseln ist veraltet. Verwenden Sie stattdessen \"-groupname %s\"." },
            { "destination.alias", "Zielalias" },
            { "destination.key.password", "Zielschl\u00FCsselkennwort" },
            { "destination.keystore.name", "Ziel-Keystore-Name" },
            { "destination.keystore.password", "Ziel-Keystore-Kennwort" },
            { "destination.keystore.password.protected", "Ziel-Keystore kennwortgesch\u00FCtzt" },
            { "destination.keystore.provider.name", "Ziel-Keystore-Providername" },
            { "destination.keystore.type", "Ziel-Keystore-Typ" },
            { "distinguished.name", "Distinguished Name" },
            { "do.not.prompt", "Kein Prompt" },
            { "enter.dname.components", "Geben Sie den Distinguished Name ein. Geben Sie einen einzelnen Punkt (.) an, um eine Unterkomponente leer zu lassen, oder dr\u00FCcken Sie die Eingabetaste, um den Standardwert in Klammern zu verwenden." },
            { "groupname.keysize.coexist", "Es k\u00F6nnen nicht sowohl -groupname als auch -keysize angegeben werden" },
            { "groupname.option.help", "Gruppenname. Beispiel: der Name der elliptischen Kurve." },
            { "if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified", "Wenn kein Alias angegeben ist, d\u00FCrfen destalias und srckeypass nicht angegeben werden" },
            { "if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified", "Wenn der Keystore nicht kennwortgesch\u00FCtzt ist, d\u00FCrfen -storepass, -keypass und -new nicht angegeben werden" },
            { "if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified", "Wenn -protected angegeben ist, d\u00FCrfen -storepass, -keypass und -new nicht angegeben werden" },
            { "if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified", "Wenn der Quell-Keystore nicht kennwortgesch\u00FCtzt ist, d\u00FCrfen -srcstorepass und -srckeypass nicht angegeben werden" },
            { "if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified", "Wenn -srcprotected angegeben ist, d\u00FCrfen -srcstorepass und -srckeypass nicht angegeben werden" },
            { "importing.keystore.status", "Keystore %1$s wird in %2$s importiert..." },
            { "input.file.name", "Eingabedateiname" },
            { "jks.storetype.warning", "Der %1$s-Keystore verwendet ein propriet\u00E4res Format. Es wird empfohlen, auf PKCS12 zu migrieren, das ein Industriestandardformat mit \"keytool -importkeystore -srckeystore %2$s -destkeystore %2$s -deststoretype pkcs12\" ist." },
            { "key.algorithm.name", "Schl\u00FCsselalgorithmusname" },
            { "key.algorithm.weak", "%1$s verwendet den Algorithmus %2$s. Das gilt als Sicherheitsrisiko." },
            { "key.bit", "%s-Schl\u00FCssel" },
            { "key.bit.disabled", "%s-Schl\u00FCssel (deaktiviert)" },
            { "key.bit.size", "Schl\u00FCsselbitgr\u00F6\u00DFe" },
            { "key.bit.weak", "%s-Schl\u00FCssel (schwach)" },
            { "key.password", "Schl\u00FCsselkennwort" },
            { "key.password.for.alias.", "Schl\u00FCsselkennwort f\u00FCr <{0}>" },
            { "key.size.weak", "%1$s verwendet %2$s. Dies gilt als Sicherheitsrisiko." },
            { "keyalg.option.missing.error", "Die Option -keyalg muss angegeben werden." },
            { "keystore.name", "Keystore-Name" },
            { "keystore.password", "Keystore-Kennwort" },
            { "keystore.type", "Keystore-Typ" },
            { "keytool.error.", "Keytool-Fehler: " },
            { "migrate.keystore.warning", "\"%1$s\" zu %4$s migriert. Der %2$s-Keystore wurde als \"%3$s\" gesichert." },
            { "multiple.commands.1.2", "Nur ein Befehl ist zul\u00E4ssig: Sowohl %1$s als auch %2$s wurden angegeben." },
            { "n", "N" },
            { "new.password", "Neues Kennwort" },
            { "no", "Nein" },
            { "no.field.in.dname", "Mindestens ein Feld muss ausgef\u00FCllt werden. Wiederholen Sie die Eingabe." },
            { "one.in.many", "%1$s #%2$d von %3$d" },
            { "one.in.many1", "%1$s #%2$d" },
            { "one.in.many2", "%1$s von Signaturgeber #%2$d" },
            { "one.in.many3", "%1$s #%2$d von Signaturgeber #%3$d" },
            { "option.1.set.twice", "Die Option %s wurde mehrmals angegeben. Alle Angaben bis auf die letzte werden ignoriert." },
            { "output.file.name", "Ausgabedateiname" },
            { "output.in.RFC.style", "Ausgabe in RFC-Stil" },
            { "password.through.protected.mechanism", "Kennwort \u00FCber gesch\u00FCtzten Mechanismus" },
            { "provclass.not.a.provider", "%s kein Provider" },
            { "provider.class.not.found", "Provider \"%s\" nicht gefunden" },
            { "provider.class.option", "Sicherheitsprovider nach vollst\u00E4ndig angegebenem Klassennamen hinzuf\u00FCgen\nArgument f\u00FCr -providerclass konfigurieren" },
            { "provider.classpath", "Provider-Classpath" },
            { "provider.name", "Providername" },
            { "provider.name.not.found", "Provider namens \"%s\" nicht gefunden" },
            { "reply", "Antwort" },
            { "showinfo.command.help", "Zeigt sicherheitsbezogene Informationen an" },
            { "showinfo.no.option", "Fehlende Option f\u00FCr -showinfo. Verwenden Sie keytool -showinfo -tls." },
            { "signature.algorithm.name", "Signaturalgorithmusname" },
            { "signed.jar.file", "Signierte JAR-Datei" },
            { "signer.alias", "Signaturgeberalias" },
            { "signer.key.password", "Signaturgeber-Schl\u00FCsselkennwort" },
            { "size.bit.alg", "%1$d-Bit-%2$s" },
            { "source.alias", "Quellalias" },
            { "source.key.password", "Quellschl\u00FCsselkennwort" },
            { "source.keystore.name", "Quell-Keystore-Name" },
            { "source.keystore.password", "Quell-Keystore-Kennwort" },
            { "source.keystore.password.protected", "Quell-Keystore kennwortgesch\u00FCtzt" },
            { "source.keystore.provider.name", "Quell-Keystore-Providername" },
            { "source.keystore.type", "Quell-Keystore-Typ" },
            { "the.certificate", "Das Zertifikat" },
            { "the.certificate.request", "Die Zertifikatsanforderung" },
            { "the.crl", "Die CRL" },
            { "the.generated.certificate", "Das generierte Zertifikat" },
            { "the.generated.certificate.request", "Die generierte Zertifikatsanforderung" },
            { "the.generated.crl", "Die generierte CRL" },
            { "the.generated.secretkey", "Der generierte Secret Key" },
            { "the.input", "Die Eingabe" },
            { "the.issuer", "Der Aussteller" },
            { "the.keystore.or.storetype.option.cannot.be.used.with.the.cacerts.option", "Die Option -keystore oder -storetype kann nicht mit der Option -cacerts verwendet werden" },
            { "the.tsa.certificate", "Das TSA-Zertifikat" },
            { "tls.option.help", "Zeigt TLS-Konfigurationsinformationen an" },
            { "trust.certificates.from.cacerts", "Zertifikaten aus cacerts vertrauen" },
            { "validity.number.of.days", "G\u00FCltigkeitsdauer (Tage)" },
            { "verbose.output", "Verbose-Ausgabe" },
            { "verified.by.s.in.s.weak", "Von %1$s in %2$s mit %3$s verifiziert" },
            { "warning.cacerts.option", "Warnung: Verwenden Sie die Option -cacerts f\u00FCr den Zugriff auf den cacerts Keystore" },
            { "warning.not.verified.make.sure.keystore.is.correct", "WARNUNG: Nicht gepr\u00FCft. Stellen Sie sicher, dass -keystore korrekt ist." },
            { "warning.not.verified.make.sure.keystore.is.correct.or.specify.trustcacerts", "Warnung: Nicht gepr\u00FCft. Stellen Sie sicher, dass -keystore korrekt ist, oder geben Sie -trustcacerts an." },
            { "whose.key.disabled", "%1$s verwendet %2$s. Dies gilt als Sicherheitsrisiko und ist deaktiviert." },
            { "whose.key.weak", "%1$s verwendet %2$s. Das gilt als Sicherheitsrisiko. Dieser Schl\u00FCssel wird in einem zuk\u00FCnftigen Update deaktiviert." },
            { "whose.sigalg.disabled", "%1$s verwendet den Signaturalgorithmus %2$s. Dies gilt als Sicherheitsrisiko und ist deaktiviert." },
            { "whose.sigalg.usagesignedjar", "%1$s verwendet den Signaturalgorithmus %2$s. Das gilt als Sicherheitsrisiko und kann nach %3$s nicht zum Signieren von JAR-Archiven verwendet werden." },
            { "whose.sigalg.weak", "%1$s verwendet den Signaturalgorithmus %2$s. Dies gilt als Sicherheitsrisiko." },
            { "with.disabled", "%s (deaktiviert)" },
            { "with.weak", "%s (schwach)" },
            { "y", "J" },
            { "yes", "Ja" },
        };
    }
}
